# React | React 완벽가이드 with Redux, Next, TypeScript | Section12

**📌유데미 강의**

https://kmooc.udemy.com/course/best-react/learn/lecture/28517031#overview

## **Section12 : 리액트와 최적화 테크닉 살펴보기**

### 161. 리액트가 실제로 작동하는 방식

리액트는 컴포넌트를 통해 유저 인터페이스를 효과적으로 구성하고, 업데이트함

리액트돔은 웹에 대한 인터페이스

리액트는 웹을 모른다, 브라우저와 전혀 관계 없는 리액트

리액트는 어떻게 컴포넌트 다루는지 알고 있지만 이러한 컴포넌트에 html이 들어있는지 허구적인 요소들이 들어 있는지 상관하지 않음

리액트돔이 고려할 것

리액트 돔은 브라우저의 일부인 실제 DOM에 대한 작업을 하므로 따라서 사용자가 보고 있는 화면에 무언가를 표시하는 역할은 리액트 돔의 몫이다.

리액트는 컴포넌트만 신경 쓰고 props를 관리한다. Props는 컴포넌트에 전달하는 데이터로 컴포넌트 구성을 가능하게 해주고, 부모-자식 간 통신을 연결, 컴포넌트 내부의 데이터인 State라는 것을 다룬다. 또한 컴포넌트 전체 상태인 Context도 다룸

1. 리액트를 통해 컴포넌트가 업데이트되고, 리액트가 화면에 새로운 것을 표시하는지에 대해 확인
2. 리액트는 리액트 DOM에 이를 알려 리액트 DOM이 새로운 화면과 새로운 컴포넌트 그리고 새 출력을 표시할 수 있게 해준다.

→리액트는 컴포넌트만 신경 쓰면서 가상 DOM이라는 개념을 사용

이 가상 돔은 앱이 마지막으로 만들어낸 컴포넌트 트리를 결정.

각각 하위 트리를 갖고 있는 컴포넌트들은 JSX코드를 반환.

이 가상 DOM은 컴포넌트 트리의 현재 모양과 최종 모양을 정함.

상태가 업데이트되면 이 정보는 리액트돔으로 전달되어 업데이트 전후 차이를 보고 리액트가 컴포넌트 트릴 통해 구성한 가상 스냅샷인 가상 돔과 일치하도록 실제 돔을 조작하는 방법

→리액트는 상태나 props,컨텍스트, 컴포넌트에 변경이 발생하면 컴포넌트 함수가 재실행되어 재평가한다.

하지만 재실행이 실제 돔을 다시 렌더링하는 것이 아님

실제 돔은 이전상태와 현재상태를 비교하여 차이점을 기반으로 변경이 필요할 때만 업데이트됨

→이전상태와 현재 상태를 가상으로 비교하는 건 간편하고 자원도 적게 든다. 메모리 안에서만 발생

리액트는 가상 DOM과의 비교를 통해 최종 스냅샷과 현재 스냅샷을 실제 DOM에 전달하는 구조

리액트는 컴포넌트를 신경쓰는데 props,컨텍스트, 컴포넌트에서 변경이 발생하면 재실행되어 재평가된다. 리액트가 가상 돔으로 비교하여 현재와 최종을 실제 DOM에 전달하면 실제 DOM이 이전 상태와 현재 상태의 차이점을 기반으로 변경이 필요할 때만 업데이트한다.

### 164. react.memo() 로 불필요한 재평가 방지

연결된 모든 컴포넌트가 다시 재실행, 재평가되면 확실히 성능이 저하될 수도 있다.

작은 규모에서는 문제가 되지 않을 수도 있지만 큰 프로젝트에서는 좀 더 최적화가 필요하다.

특정상황에서만 자식 컴포넌트가 재실행하도록 리액트에 지시할 수 있다.

```jsx
import React from 'react';

const DemoOutput = props => {
  return <p>{props.show ? 'This is new!' : ''}</p>;
};

export default React.memo(DemoOutput);
```

내보낼 때 React.memo()로 감싸기

- 처음 실행하고 나중엔 변경된 부분이 없으면 재실행 되지 않음
- 모든 컴포넌트에 할 필요없다 ⇒ 부모가 실행될 때마다 바뀌어야 하는 컴포넌트라면 안 쓰는 게 좋다.
- 상위 컴포넌트에 적용하면 하위 컴포넌트 트리도 같이 적용 되지 않는 성능에 최적화될 수도 있다.
- 배열이나 객체 함수를 이전 상황과 비교했을 때 사람 눈에는 같아 보여도 자바스크립트에겐 이 값이 같지 않음
- 원시값인 문자열 숫자 불리언은 같게 쳐주지만 참조값은 아니다.

**Q.** React.memo 는 props 를 통한 객체나 배열 또는 함수를 가져오는 컴포넌트에는 사용할 수 없는 걸까?

### 165. useCallback()으로 함수 재생성 방지하기

React.memo는 객체 외에 prop 값에도 접근할 수 있게 되있음

객체 생성하고 저장하는 방식만 조금 변경해주면 된다.

useCallback훅은 컴포넌트 실행 전반에 걸쳐 함수를 저장할 수 있게 하는 훅

- 리액트에 함수를 저장하고 매번 실행할 때마다 재실행하지 않아도 된다는 걸 알려줄 수 있음
- 동일한 함수가 메모리의 동일한 위치에 저장 이를 통해 비교 작업
- 저장하려는 함수를 랩핑하여 함수를 첫번째 인자로 전달하면 useCallback은 저장된 함수를 반환

```jsx
const toggleParagraphHandler = useCallback(() => {
  setShowParagraph(prevParagraph => !prevParagraph);
});
```

- 부모 컴포넌트가 실행되면 리액트가 저장한 함수를 찾아서 같은 함수 객체를 재사용
- 함수가 절대 변경되어서는 안되면 useCallback을 사용해 함수를 저장
- useEffect와 마찬가지로 두 번째 인자 필요, useCallback호출에 대한 의존성 배열

```
const toggleParagraphHandler = useCallback(() => {
    setShowParagraph(prevParagraph => !prevParagraph);
  }, []);
```

- 빈 배열로 하면 부모 컴포턴트가 다시 렌더링되어도 항상 같은 함수 객체가 사용되게끔 함

### 166. useCallback()및 해당 종속성

**클로저**

함수 밖에 선언된 변수를 함수 안에서 변수가 저장된 시점의 값을 쓸 수 있음

```jsx
const [allowToggle, setAllowToggle] = useState(false);
const [showParagraph, setShowParagraph] = useState(false);

const toggleParagraphHandler = useCallback(() => {
  if (allowToggle) {
    setShowParagraph(prevParagraph => !prevParagraph);
  }
}, [allowToggle]);

const allowToggleHandler = () => {
  setAllowToggle(true);
};
```

### 168. State및 컴포넌트

리액트는 상태를 관리하고 컴포넌트와의 연결을 관리

리액트는 useState와 useState에 전달되는 기본값에 대해서 최초 실행될 때 한 번만 고려되도록 처리

DOM에 컴포넌트가 연결되고 유지되는 동안에는 상태는 최초의 초기화 이후에는 갱신만 된다.

### 169. State 스케줄링 및 일괄 처리

리액트가 상태 관리와 갱신을 담당

리액트는 상태 변화가 일어나면, 상태 변화의 순서를 명확히 해서, 같은 타입임을 보증하고 이전 상태를 기반으로 매회 상태 변경이 발생할 때마다 가장 최신의 상태를 얻게 해주는 안전한 방법

스케줄링을 지연시킬 수 있음

동시에 여러 번의 갱신이 스케줄될 수 있으므로 상태를 갱신할 때는 함수 형태를 이용해서 갱신하는 것 추천

하지만 빠르기 때문에 잠깐의 지연을 못 느낀다.

- 리액트가 미완료된 상태 변경 작업에 대해 최신의 상태를 이용하고 컴포넌트가 재렌더링되었을 그 시점의 상태를 사용하지 않게 됨
- 하나의 컴포넌트가 재평가되면서 미완료된 상태 변경 작업이 여러 개 있을 수 있다.

→함수 형태가 중요한 이유

갱신 예약이 된 뒤 다시 컴포넌트가 실행

컴포넌트가 다시 실행되고 나서야 사용 가능한 최신 상태가 된다.

한 함수에 두 개의 상태변화가 있다면 (어떠한 콜백이나 프로미스 없이 실행된다면)

리액트는 이 함수로부터 발생되는 모든 상태 갱신 작업을 하나의 상태 갱신 작업으로 처리

### 170. useMemo로 최적화하기

```jsx
const listItems = useMemo(() => [5, 3, 1, 10, 9], []);

return <DemoList title={listTitle} item={listItems} />;
```

불필요한 재렌더링을 막음

useMemo를 사용해 데이터를 저장하면 메모리를 사용하는 것 함수 저장 또한 스케줄링 성능을 사용하는 것

useCallback 보다는 덜 쓰임
